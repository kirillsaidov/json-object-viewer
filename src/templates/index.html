<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Constructor</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            justify-content: flex-start;
        }

        .btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn.primary {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            border: none;
        }

        .btn.primary:hover {
            background-color: #0056b3;
        }

        .btn.secondary {
            background: linear-gradient(135deg, #00d2d3, #54a0ff);
            border: none;
        }

        .btn.buttonStyle3 {
            background: linear-gradient(135deg, #6c5ce7, #341f97);
            border: none;
        }

        .btn.buttonStyle4 {
            background: linear-gradient(135deg, #00f2c3, #0abde3); 
            border: none;
        }

        .btn.buttonStyle5 {
            background: linear-gradient(135deg, #f6d365, #fda085); 
            border: none;
        }

        .btn.buttonStyle6 {
            background: linear-gradient(135deg, #6c5ce7, #0abde3); 
            border: none;
        }

        .btn.buttonStyle7 {
            background: linear-gradient(135deg, #00d647, #11cc00); 
            border: solid;
        }

        .btn.buttonStyle8 {
            background: linear-gradient(135deg, #ff7070, #e85bec); 
            border: none;
        }

        .btn.buttonStyle9 {
            background: linear-gradient(135deg, #008f3b, #35cf3d); 
            border: none;
        }

        .canvas-container {
            overflow: auto;
            position: relative;
            width: 100%;
            height: 100vh; /* Adjust based on header height */
        }

        #canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .block {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1rem;
            min-width: 200px;
            max-width: none; /* Remove max-width constraint */
            width: 320px; /* Default width */
            height: 480px; /* Fixed height */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: move;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .block:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .block.selected {
            border: 2px solid #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }

        .block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .block-id {
            font-weight: bold;
            color: #333;
            font-size: 1.1rem;
        }

        .block-content {
            flex: 1;
            overflow-y: auto;
            margin-top: 0.5rem;
        }

        .block-content::-webkit-scrollbar {
            width: 6px;
        }

        .block-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
        }

        .block-content::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }

        .block-content::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.5);
        }

        .delete-btn {
            background: #ff4757;
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .field {
            margin-bottom: 0.5rem;
            padding: 0.3rem;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .field-key {
            font-weight: bold;
            color: #2c3e50;
        }

        .field-value {
            color: #34495e;
            word-break: break-word;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            padding: 2rem;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content.markdown-modal {
            max-width: 1000px;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
            color: #333;
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .form-group textarea {
            height: 100px;
            resize: vertical;
        }

        .field-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 0.5rem;
        }

        .field-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.3rem;
            background: #f8f9fa;
            margin-bottom: 0.3rem;
            border-radius: 4px;
        }

        .field-item:last-child {
            margin-bottom: 0;
        }

        .remove-field {
            background: #dc3545;
            color: white;
            border: none;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        #json-output {
            background: #2d3748;
            color: #e2e8f0;
            border: none;
            border-radius: 8px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            width: 100%;
            height: 300px;
            resize: vertical;
        }

        .arrow {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .arrow-line {
            stroke: #ff6b6b;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .connection-mode {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e) !important;
        }

        .remove-connection-mode {
            background: linear-gradient(135deg, #ff7675, #fd79a8) !important;
        }

        .arrow-line {
            stroke: #ff6b6b;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
            cursor: pointer;
            transition: stroke-width 0.2s ease;
        }

        .remove-mode .arrow-line {
            cursor: crosshair;
            stroke-width: 8;
        }

        .remove-mode .arrow-line:hover {
            stroke: #ff4757;
            stroke-width: 10;
        }

        .help-section {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
        }

        .help-section h3 {
            border-bottom: 2px solid #6c5ce7;
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            color: #2d3436;
        }

        .markdown-content {
            line-height: 1.6;
            color: #333;
        }
        
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }
        
        .markdown-content h1 {
            font-size: 2rem;
            border-bottom: 2px solid #3498db;
            padding-bottom: 0.5rem;
        }
        
        .markdown-content h2 {
            font-size: 1.5rem;
            border-bottom: 1px solid #bdc3c7;
            padding-bottom: 0.3rem;
        }
        
        .markdown-content h3 {
            font-size: 1.2rem;
        }
        
        .markdown-content ul, .markdown-content ol {
            margin: 1rem 0;
            padding-left: 2rem;
        }
        
        .markdown-content li {
            margin-bottom: 0.5rem;
        }
        
        .markdown-content p {
            margin: 1rem 0;
        }
        
        .markdown-content code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .markdown-content pre {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            border-left: 4px solid #3498db;
        }
        
        .markdown-content blockquote {
            border-left: 4px solid #3498db;
            margin: 1rem 0;
            padding-left: 1rem;
            color: #555;
            font-style: italic;
        }
        
        .markdown-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }
        
        .markdown-content th, .markdown-content td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        .markdown-content th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        .markdown-content strong {
            color: #2c3e50;
        }
        
        .markdown-content em {
            color: #7f8c8d;
        }
        
        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            cursor: pointer;
            color: #999;
        }
        
        .close-btn:hover {
            color: #333;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="controls">
            <button class="btn primary" onclick="createBlock()">Create Block</button>
            <button class="btn secondary" onclick="toggleConnectionMode()">Connect Blocks</button>
            <button class="btn secondary" onclick="toggleRemoveConnectionMode()">Remove Connections</button>
            <button class="btn buttonStyle8" onclick="clearAll()">Clear All</button>
            <button class="btn buttonStyle9" onclick="exportToJSON()">Export JSON</button>
            <input type="file" id="jsonFileInput" accept=".json" style="display: none;" onchange="importFromJSON(event)">
            <button class="btn buttonStyle9" onclick="document.getElementById('jsonFileInput').click()">Import JSON</button>
            <button class="btn buttonStyle5" onclick="downloadSVG()">Download SVG</button>
            <button class="btn buttonStyle5" onclick="downloadJPEG()">Download JPEG</button>
            <button class="btn buttonStyle3" onclick="exportCache()">Export Graph File</button>
            <input type="file" id="cacheFileInput" accept=".graph.json" style="display: none;" onchange="importCache(event)">
            <button class="btn buttonStyle3" onclick="document.getElementById('cacheFileInput').click()">Import Graph File</button>
            <button class="btn buttonStyle4" onclick="openSaveGraphModal()">Save Graph File</button>
            <button class="btn buttonStyle4" onclick="openLoadGraphModal()">Load Graph File</button>
            <button class="btn buttonStyle7" onclick="openHelpModal()" title="Help">?</button>
        </div>
    </div>

    <div class="canvas-container" id="canvasWrapper">
        <div id="canvas" style="position: relative; transform: scale(1); transform-origin: top left;">
            <svg id="arrows" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#ff6b6b" />
                    </marker>
                </defs>
            </svg>
        </div>
    </div>

    <!-- Block Creation Modal -->
    <div id="blockModal" class="modal">
        <div class="modal-content">
            <h2>Create/Edit Block</h2>
            <div class="form-group">
                <label for="blockId">Block ID:</label>
                <input type="text" id="blockId" placeholder="Enter block ID">
            </div>
            
            <div class="form-group">
                <label for="fieldKey">Field Key:</label>
                <input type="text" id="fieldKey" placeholder="Enter field key">
            </div>
            <div class="form-group">
                <label for="fieldType">Field Type:</label>
                <select id="fieldType">
                    <option value="string">String</option>
                    <option value="number">Number</option>
                    <option value="boolean">Boolean</option>
                    <option value="array">Array (JSON)</option>
                    <option value="object">Object (JSON)</option>
                </select>
            </div>
            <div class="form-group">
                <label for="fieldValue">Field Value:</label>
                <textarea id="fieldValue" placeholder="Enter field value"></textarea>
            </div>

            <div style="margin-top: 1rem; margin-bottom: 1rem; display: flex; gap: 1rem;">
                <button class="btn secondary" onclick="addField()">Add Field</button>
            </div>
            
            <div class="field-list" id="fieldList"></div>

            <div style="margin-top: 1rem;" class="form-group">
                <label for="blockWidth">Block Width (px):</label>
                <input type="number" id="blockWidth" value="320" min="150" max="500">
            </div>
            <div class="form-group">
                <label for="blockHeight">Block Height (px):</label>
                <input type="number" id="blockHeight" value="480" min="100" max="400">
            </div>
            <div style="margin-top: 1rem; display: flex; gap: 1rem;">
                <button class="btn primary" onclick="saveBlock()">Save Block</button>
                <button class="btn" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- JSON Export Modal -->
    <div id="jsonModal" class="modal">
        <div class="modal-content">
            <h2>JSON Export</h2>
            <textarea id="json-output" readonly></textarea>
            <div style="margin-top: 1rem; display: flex; gap: 1rem;">
                <button class="btn primary" onclick="copyJSON()">Copy to Clipboard</button>
                <button class="btn secondary" onclick="downloadJSON()">Download JSON</button>
                <button class="btn" onclick="closeJSONModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Arrow Text Modal -->
    <div id="arrowTextModal" class="modal">
        <div class="modal-content">
            <h2>Edit Arrow Text</h2>
            <div class="form-group">
                <label for="arrowText">Arrow Text:</label>
                <input type="text" id="arrowText" placeholder="Enter text for this arrow">
            </div>
            <div class="form-group">
                <label for="arrowFontSize">Font Size (px):</label>
                <input type="number" id="arrowFontSize" value="12" min="8" max="24" step="1">
            </div>
            <div style="margin-top: 1rem; display: flex; gap: 1rem;">
                <button class="btn primary" onclick="saveArrowText()">Save</button>
                <button class="btn" onclick="closeArrowTextModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Edit Field Modal -->
    <div id="editFieldModal" class="modal">
        <div class="modal-content">
            <h2>Edit Field</h2>
            <div class="form-group">
                <label for="editFieldKey">Field Key:</label>
                <input type="text" id="editFieldKey" placeholder="Enter field key">
            </div>
            <div class="form-group">
                <label for="editFieldType">Field Type:</label>
                <select id="editFieldType">
                    <option value="string">String</option>
                    <option value="number">Number</option>
                    <option value="boolean">Boolean</option>
                    <option value="array">Array (JSON)</option>
                    <option value="object">Object (JSON)</option>
                </select>
            </div>
            <div class="form-group">
                <label for="editFieldValue">Field Value:</label>
                <textarea id="editFieldValue" placeholder="Enter field value"></textarea>
            </div>
            <div style="margin-top: 1rem; display: flex; gap: 1rem;">
                <button class="btn primary" onclick="saveEditedField()">Save</button>
                <button class="btn" onclick="closeEditFieldModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content markdown-modal">
            <span class="close-btn" onclick="closeHelpModal()">&times;</span>
            <div id="markdownContent" class="markdown-content">
                <!-- Markdown content will be rendered here -->
            </div>
            <div style="margin-top: 2rem; text-align: center;">
                <button class="btn primary" onclick="closeHelpModal()">Got It!</button>
            </div>
        </div>
    </div>

    <!-- Save Graph Modal -->
    <div id="saveGraphModal" class="modal">
        <div class="modal-content">
            <h2>Save Graph to Server</h2>
            <div class="form-group">
                <label for="graphFileName">File Name:</label>
                <input type="text" id="graphFileName" placeholder="Enter file name">
            </div>
            <div id="saveGraphMessage" style="margin: 10px 0; color: #ff6b6b; display: none;"></div>
            <div style="margin-top: 1rem; display: flex; gap: 1rem;">
                <button class="btn primary" onclick="saveGraphToServer()">Save</button>
                <button class="btn" onclick="closeSaveGraphModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Load Graph Modal -->
    <div id="loadGraphModal" class="modal">
        <div class="modal-content">
            <h2>Load Graph from Server</h2>
            <div id="graphFilesList" class="field-list" style="margin-top: 1rem; max-height: 300px; overflow-y: auto;">
                <!-- List of graph files will be populated here -->
            </div>
            <div style="margin-top: 1rem; display: flex; gap: 1rem;">
                <button class="btn" onclick="closeLoadGraphModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        let blocks = {};
        let connections = [];
        let currentBlock = null;
        let blockFields = [];
        let isConnectionMode = false;
        let isRemoveConnectionMode = false;
        let selectedBlock = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let isPanning = false;
        let startPan = { x: 0, y: 0 };
        let scrollStart = { x: 0, y: 0 };
        let canvasZoom = 1;
        let currentArrowIndex = -1;
        let currentEditingFieldIndex = -1;
        const minZoom = 0.2;
        const maxZoom = 3;
        const markdownText = `# 🧱 Block Constructor Help

Your interactive guide to building, connecting, editing, and exporting visual workflows effortlessly.

---

## ⌨️ Shortcuts & Gestures

| Action                 | Description                                           |
| ---------------------- | ----------------------------------------------------- |
| 🖱️ **Move Canvas**    | Click + drag empty canvas area                        |
| 🔍 **Zoom**            | Hold \`Ctrl\` / \`Cmd\` + scroll mouse wheel              |
| 🧲 **Move Block**      | Click + drag a block                                  |
| ✏️ **Edit Block**      | Double-click a block                                  |
| ❌ **Delete Block**     | Click the **×** button on the block                   |
| 🧬 **Duplicate Block** | Click the **⧉** icon on the block                     |
| 🧹 **Clear Canvas**    | Click the **"Clear All"** button                      |

---

## 🧰 Using the Block Constructor

### ➕ Create a New Block

Click **"Create Block"** to define:
- Unique ID
- Fields with key, type (string, number, boolean, array, object), and value
- Custom width and height

Use the **"Add Field"** button to add multiple fields. Edit or remove them via the field list below.

---

### 🔗 Connect Blocks

Click **"Connect Blocks"** to create directional arrows:

1. Click a **source block**
2. Click a **target block**
3. Click **"Connect Blocks"** again to exit connection mode

---

### 🏷️ Edit Connection Labels

Click on a **connection arrow** to:
- Add or change label text
- Adjust font size of the label

---

### ✂️ Remove a Connection

1. Click **"Remove Connections"**
2. Click the connection you want to delete
3. Click **"Remove Connections"** again to exit

---

## 🖼️ Canvas & Block Customization

- Blocks are draggable
- Canvas resizes dynamically
- Use **zoom** and **pan** to explore large diagrams
- Blocks have persistent size (width & height) and store field values with proper types

---

## 💾 Export & Import Options

| Option                        | Details                                                                       |
| ----------------------------- | ----------------------------------------------------------------------------- |
| 🧠 **Export Graph File**      | Saves blocks, connections, metadata to a \`.graph.json\` file                   |
| 🔄 **Import Graph File**      | Load a full project from a \`.graph.json\` file                                 |
| 🧾 **Export as \`json\`**        | Exports blocks only (IDs + fields) — ideal for developers                     |
| 🔄 **Import \`json\`**           | Imports only block data (no layout or connections)                            |

---

## 🌐 Save & Load from Server

- **Save Graph File**: Store your project on the server using a custom file name  
  ➤ If a file exists, you'll be prompted before overwriting.

- **Load Graph File**: View a list of saved \`.graph.json\` files on the server and load them into your canvas.

---

## 🖼️ Export as Image

| Format       | Description                                           |
| ------------ | ----------------------------------------------------- |
| 🖼️ **SVG**   | Vector-quality export of the canvas, preserves text   |
| 🖼️ **JPEG**  | Raster export of current canvas view                  |

---

## 🧠 Tips

- All work is automatically cached in localStorage
- Use **Import Graph File** to restore saved work
- Use **Duplicate Block** to quickly reuse structures
- Field types like arrays or objects must be valid JSON

---

Enjoy building your workflows visually with **Block Constructor**!
`;

        const canvasWrapper = document.getElementById("canvasWrapper");

        canvasWrapper.addEventListener("mousedown", function(e) {
            if (e.target.id === "canvas" || e.target.id === "canvasWrapper") {
                isPanning = true;
                startPan = { x: e.clientX, y: e.clientY };
                scrollStart = { x: canvasWrapper.scrollLeft, y: canvasWrapper.scrollTop };
                canvasWrapper.style.cursor = "grabbing";
            }
        });

        canvasWrapper.addEventListener("wheel", function (e) {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();

                // Calculate current mouse position relative to canvas
                const rect = canvasWrapper.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Calculate current scroll percentages
                const scrollXPercent = mouseX / canvasWrapper.clientWidth;
                const scrollYPercent = mouseY / canvasWrapper.clientHeight;

                // Calculate new zoom level
                const zoomStep = 0.1;
                const delta = e.deltaY > 0 ? -zoomStep : zoomStep;
                const newZoom = Math.min(maxZoom, Math.max(minZoom, canvasZoom + delta));
                if (newZoom === canvasZoom) return;

                // Save current scroll positions
                const oldScrollLeft = canvasWrapper.scrollLeft;
                const oldScrollTop = canvasWrapper.scrollTop;

                // Apply new zoom
                canvasZoom = newZoom;
                document.getElementById("canvas").style.transform = `scale(${canvasZoom})`;

                // Calculate new scroll positions to keep mouse centered
                canvasWrapper.scrollLeft = oldScrollLeft + (mouseX - scrollXPercent * canvasWrapper.clientWidth);
                canvasWrapper.scrollTop = oldScrollTop + (mouseY - scrollYPercent * canvasWrapper.clientHeight);
            }
        }, { passive: false });

        window.addEventListener("mouseup", function() {
            isPanning = false;
            canvasWrapper.style.cursor = "grab";
        });

        window.addEventListener("mousemove", function(e) {
            if (!isPanning) return;
            const dx = e.clientX - startPan.x;
            const dy = e.clientY - startPan.y;
            canvasWrapper.scrollLeft = scrollStart.x - dx;
            canvasWrapper.scrollTop = scrollStart.y - dy; // Changed to -dy for vertical
        });

        function openHelpModal() {
            // Convert markdown to HTML
            const htmlContent = marked.parse(markdownText);
            document.getElementById('markdownContent').innerHTML = htmlContent;
            document.getElementById('helpModal').style.display = 'block';
        }

        function closeHelpModal() {
            document.getElementById('helpModal').style.display = 'none';
        }

        // Add this function to handle loading cache data
        function loadCacheData(cacheData) {
            blocks = cacheData.blocks || {};
            connections = cacheData.connections || [];
            renderBlocks();
            updateCanvasSize();
            renderConnections();
            saveToCache(); // Save to localStorage
        }

        // Add export cache function
        function exportCache() {
            const cacheData = {
                blocks: blocks,
                connections: connections,
                timestamp: Date.now()
            };
            
            const jsonString = JSON.stringify(cacheData);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `block_constructor_cache_${new Date().toISOString().slice(0, 10)}.graph.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Add import cache function
        function importCache(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const cacheData = JSON.parse(e.target.result);
                    loadCacheData(cacheData);
                    alert("Cache imported successfully!");
                } catch (err) {
                    alert("Invalid cache file format");
                    console.error(err);
                }
            };
            reader.readAsText(file);
        }

        // Save blocks and connections to localStorage
        function saveToCache() {
            const cacheData = {
                blocks: blocks,
                connections: connections,
                timestamp: Date.now()
            };
            localStorage.setItem('blockConstructorCache', JSON.stringify(cacheData));
        }

        // Load blocks and connections from localStorage
        function loadFromCache() {
            try {
                const cached = localStorage.getItem('blockConstructorCache');
                if (cached) {
                    const cacheData = JSON.parse(cached);
                    blocks = cacheData.blocks || {};
                    connections = cacheData.connections || [];
                    renderBlocks();
                    updateCanvasSize();
                    renderConnections();
                    console.log('Loaded from cache:', Object.keys(blocks).length, 'blocks');
                }
            } catch (error) {
                console.error('Error loading from cache:', error);
            }
        }

        function updateCanvasSize() {
            let maxRight = 4000;
            let maxBottom = 4000;

            Object.values(blocks).forEach(block => {
                const right = block.position.x + (block.width || 320);
                const bottom = block.position.y + (block.height || 480);
                if (right > maxRight) maxRight = right;
                if (bottom > maxBottom) maxBottom = bottom;
            });

            maxRight += 500;
            maxBottom += 500;

            const canvas = document.getElementById('canvas');
            canvas.style.width = maxRight + 'px';
            canvas.style.height = maxBottom + 'px';
        }

        function createBlock() {
            currentBlock = null;
            blockFields = [];
            document.getElementById('blockId').value = '';
            document.getElementById('blockWidth').value = '320';
            document.getElementById('blockHeight').value = '480';
            updateFieldList();
            document.getElementById('blockModal').style.display = 'block';
        }

        function editBlock(blockId) {
            currentBlock = blockId;
            blockFields = [];
            document.getElementById('blockId').value = blockId;
            
            // Load existing fields
            const block = blocks[blockId];
            document.getElementById('blockWidth').value = block.width || 320;
            document.getElementById('blockHeight').value = block.height || 480;
            
            for (const [key, value] of Object.entries(block.data)) {
                blockFields.push({ key, value, type: getFieldType(value) });
            }
            
            updateFieldList();
            document.getElementById('blockModal').style.display = 'block';
        }

        function getFieldType(value) {
            if (typeof value === 'string') return 'string';
            if (typeof value === 'number') return 'number';
            if (typeof value === 'boolean') return 'boolean';
            if (Array.isArray(value)) return 'array';
            if (typeof value === 'object') return 'object';
            return 'string';
        }

        function addField() {
            const key = document.getElementById('fieldKey').value.trim();
            const type = document.getElementById('fieldType').value;
            const valueStr = document.getElementById('fieldValue').value.trim();
            
            if (!key) {
                alert('Please enter a field key');
                return;
            }

            // Allow empty values only for string type
            if (!valueStr && type !== 'string') {
                alert('Please enter a field value');
                return;
            }
            
            let value;
            try {
                switch (type) {
                    case 'string':
                        value = valueStr;
                        break;
                    case 'number':
                        value = parseFloat(valueStr);
                        if (isNaN(value)) throw new Error('Invalid number');
                        break;
                    case 'boolean':
                        value = valueStr.toLowerCase() === 'true';
                        break;
                    case 'array':
                    case 'object':
                        value = JSON.parse(valueStr);
                        break;
                }
            } catch (e) {
                alert('Invalid value format for selected type');
                return;
            }
            
            blockFields.push({ key, value, type });
            updateFieldList();
            
            // Clear inputs
            document.getElementById('fieldKey').value = '';
            document.getElementById('fieldValue').value = '';
        }

        function removeField(index) {
            blockFields.splice(index, 1);
            updateFieldList();
        }

        function editField(index) {
            currentEditingFieldIndex = index;
            const field = blockFields[index];
            
            document.getElementById('editFieldKey').value = field.key;
            document.getElementById('editFieldType').value = field.type;
            document.getElementById('editFieldValue').value = typeof field.value === 'string' ? field.value : JSON.stringify(field.value);
            
            document.getElementById('editFieldModal').style.display = 'block';
        }

        function saveEditedField() {
            if (currentEditingFieldIndex === -1) return;
            
            const key = document.getElementById('editFieldKey').value.trim();
            const type = document.getElementById('editFieldType').value;
            const valueStr = document.getElementById('editFieldValue').value.trim();
            
            if (!key) {
                alert('Please enter a field key');
                return;
            }

            // Allow empty values only for string type
            if (!valueStr && type !== 'string') {
                alert('Please enter a field value');
                return;
            }
            
            let value;
            try {
                switch (type) {
                    case 'string':
                        value = valueStr;
                        break;
                    case 'number':
                        value = parseFloat(valueStr);
                        if (isNaN(value)) throw new Error('Invalid number');
                        break;
                    case 'boolean':
                        value = valueStr.toLowerCase() === 'true';
                        break;
                    case 'array':
                    case 'object':
                        value = JSON.parse(valueStr);
                        break;
                }
            } catch (e) {
                alert('Invalid value format for selected type');
                return;
            }
            
            blockFields[currentEditingFieldIndex] = { key, value, type };
            updateFieldList();
            closeEditFieldModal();
        }

        function closeEditFieldModal() {
            document.getElementById('editFieldModal').style.display = 'none';
            currentEditingFieldIndex = -1;
        }

        function updateFieldList() {
            const fieldList = document.getElementById('fieldList');
            fieldList.innerHTML = '';
            
            blockFields.forEach((field, index) => {
                const fieldItem = document.createElement('div');
                fieldItem.className = 'field-item';
                fieldItem.innerHTML = `
                    <span><strong>${field.key}:</strong> ${JSON.stringify(field.value)}</span>
                    <div>
                        <button class="edit-field" onclick="editField(${index})" style="background: #007bff; color: white; border: none; padding: 0.2rem 0.5rem; border-radius: 3px; cursor: pointer; font-size: 0.8rem; margin-right: 0.3rem;">Edit</button>
                        <button class="remove-field" onclick="removeField(${index})">Remove</button>
                    </div>
                `;
                fieldList.appendChild(fieldItem);
            });
        }

        function saveBlock() {
            const blockId = document.getElementById('blockId').value.trim();
            const blockWidth = parseInt(document.getElementById('blockWidth').value) || 320;
            const blockHeight = parseInt(document.getElementById('blockHeight').value) || 480;
            
            if (!blockId) {
                alert('Please enter a block ID');
                return;
            }
            
            // Check for duplicate ID (only for new blocks or when ID is changed)
            if (blocks[blockId] && (!currentBlock || currentBlock !== blockId)) {
                alert(`Block ID "${blockId}" already exists. Please use a unique ID.`);
                return;
            }

            const blockData = {};
            blockFields.forEach(field => {
                blockData[field.key] = field.value;
            });
            
            // Handle ID change for existing blocks
            if (currentBlock && currentBlock !== blockId) {
                // Remove old block entry
                const oldPosition = blocks[currentBlock].position;
                delete blocks[currentBlock];
                
                // Update connections to use new ID
                connections = connections.map(conn => {
                    if (conn.from === currentBlock) conn.from = blockId;
                    if (conn.to === currentBlock) conn.to = blockId;
                    return conn;
                });
                
                // Create new entry with updated ID
                blocks[blockId] = {
                    id: blockId,
                    data: blockData,
                    position: oldPosition,
                    width: blockWidth,
                    height: blockHeight
                };
            } else {
                // Create new block or update existing with same ID
                blocks[blockId] = {
                    id: blockId,
                    data: blockData,
                    position: currentBlock ? blocks[currentBlock].position : { 
                        x: Math.random() * 300 + 50, 
                        y: Math.random() * 200 + 50 
                    },
                    width: blockWidth,
                    height: blockHeight
                };
            }
            
            renderBlocks();
            updateCanvasSize();
            renderConnections();
            closeModal();
            saveToCache();
        }

        function deleteBlock(blockId) {
            if (confirm(`Are you sure you want to delete block ${blockId}?`)) {
                delete blocks[blockId];
                connections = connections.filter(conn => conn.from !== blockId && conn.to !== blockId);
                renderBlocks();
                updateCanvasSize();
                renderConnections();
                saveToCache();
            }
        }

        function duplicateBlock(blockId) {
            const originalBlock = blocks[blockId];
            if (!originalBlock) return;
            
            // Generate new unique ID
            let newId = blockId + '_copy';
            let counter = 1;
            while (blocks[newId]) {
                newId = blockId + '_copy' + counter;
                counter++;
            }
            
            // Create new block with same data but different position
            blocks[newId] = {
                id: newId,
                data: JSON.parse(JSON.stringify(originalBlock.data)), // Deep copy of data
                position: { 
                    x: originalBlock.position.x + 50, // Offset by 50px right
                    y: originalBlock.position.y + 50  // Offset by 50px down
                },
                width: originalBlock.width,
                height: originalBlock.height
            };
            
            renderBlocks();
            updateCanvasSize();
            renderConnections();
            saveToCache();
        }

        function renderBlocks() {
            const canvas = document.getElementById('canvas');
            const existingBlocks = canvas.querySelectorAll('.block');
            existingBlocks.forEach(block => block.remove());
            
            for (const [blockId, block] of Object.entries(blocks)) {
                const blockElement = document.createElement('div');
                blockElement.className = 'block';
                blockElement.style.left = block.position.x + 'px';
                blockElement.style.top = block.position.y + 'px';
                blockElement.style.width = (block.width || 320) + 'px';
                blockElement.style.height = (block.height || 480) + 'px';
                blockElement.dataset.blockId = blockId;
                
                let fieldsHtml = '';
                for (const [key, value] of Object.entries(block.data)) {
                    fieldsHtml += `
                        <div class="field">
                            <span class="field-key">${key}:</span>
                            <span class="field-value">${JSON.stringify(value)}</span>
                        </div>
                    `;
                }
                
                blockElement.innerHTML = `
                    <div class="block-header">
                        <div class="block-id">${blockId}</div>
                        <div style="display: flex; gap: 5px;">
                            <button class="delete-btn" onclick="duplicateBlock('${blockId}')" title="Duplicate block" style="background: #2ecc71;">⧉</button>
                            <button class="delete-btn" onclick="deleteBlock('${blockId}')" title="Delete block">×</button>
                        </div>
                    </div>
                    <div class="block-content">
                        ${fieldsHtml}
                    </div>
                `;
                
                blockElement.addEventListener('mousedown', handleBlockMouseDown);
                blockElement.addEventListener('dblclick', () => editBlock(blockId));
                blockElement.addEventListener('click', handleBlockClick);
                
                canvas.appendChild(blockElement);
            }
        }

        function handleBlockMouseDown(e) {
            if (e.target.classList.contains('delete-btn')) return;
            
            isDragging = true;
            const blockElement = e.currentTarget;
            const blockId = blockElement.dataset.blockId;
            
            // Get the block's position in canvas coordinates (including zoom and scroll)
            const blockRect = blockElement.getBoundingClientRect();
            const canvasRect = document.getElementById('canvas').getBoundingClientRect();
            
            // Calculate the offset considering zoom and scroll
            dragOffset.x = (e.clientX - canvasRect.left + canvasWrapper.scrollLeft) / canvasZoom - parseFloat(blockElement.style.left);
            dragOffset.y = (e.clientY - canvasRect.top + canvasWrapper.scrollTop) / canvasZoom - parseFloat(blockElement.style.top);
            
            blockElement.style.zIndex = '1000';
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            e.preventDefault();
        }

        function handleMouseMove(e) {
            if (!isDragging) return;
            
            const blockElement = document.querySelector('.block[style*="z-index: 1000"]');
            if (!blockElement) return;
            
            const blockId = blockElement.dataset.blockId;
            const canvasRect = document.getElementById('canvas').getBoundingClientRect();
            
            // Calculate new position considering zoom and scroll
            const x = (e.clientX - canvasRect.left + canvasWrapper.scrollLeft) / canvasZoom - dragOffset.x;
            const y = (e.clientY - canvasRect.top + canvasWrapper.scrollTop) / canvasZoom - dragOffset.y;
            
            blockElement.style.left = Math.max(0, x) + 'px';
            blockElement.style.top = Math.max(0, y) + 'px';
            
            blocks[blockId].position = { x: Math.max(0, x), y: Math.max(0, y) };
            
            renderConnections();
        }

        function handleMouseUp() {
            isDragging = false;
            const blockElement = document.querySelector('.block[style*="z-index: 1000"]');
            if (blockElement) {
                blockElement.style.zIndex = '';
            }
            
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            updateCanvasSize();
            saveToCache();
        }

        function handleBlockClick(e) {
            if ((!isConnectionMode && !isRemoveConnectionMode) || isDragging) return;
            
            const blockId = e.currentTarget.dataset.blockId;
            
            if (isConnectionMode) {
                if (!selectedBlock) {
                    selectedBlock = blockId;
                    e.currentTarget.classList.add('selected');
                } else {
                    if (selectedBlock !== blockId) {
                        connections.push({ from: selectedBlock, to: blockId, text: '', fontSize: 16 });
                        renderConnections();
                        saveToCache();
                    }
                    document.querySelector('.block.selected')?.classList.remove('selected');
                    selectedBlock = null;
                }
            }
        }

        function toggleConnectionMode() {
            isConnectionMode = !isConnectionMode;
            isRemoveConnectionMode = false;
            const btn = event.target;
            const removeBtn = document.querySelector('button[onclick="toggleRemoveConnectionMode()"]');
            
            // Reset remove connection button
            removeBtn.textContent = 'Remove Connections';
            removeBtn.classList.remove('remove-connection-mode');
            
            if (isConnectionMode) {
                btn.textContent = 'Exit Connect Mode';
                btn.classList.add('connection-mode');
                document.getElementById('canvas').style.cursor = 'crosshair';
                document.getElementById('arrows').classList.remove('remove-mode');
            } else {
                btn.textContent = 'Connect Blocks';
                btn.classList.remove('connection-mode');
                document.getElementById('canvas').style.cursor = 'grab';
                document.querySelector('.block.selected')?.classList.remove('selected');
                selectedBlock = null;
            }
        }

        function toggleRemoveConnectionMode() {
            isRemoveConnectionMode = !isRemoveConnectionMode;
            isConnectionMode = false;
            const btn = event.target;
            const connectBtn = document.querySelector('button[onclick="toggleConnectionMode()"]');
            
            // Reset connection button
            connectBtn.textContent = 'Connect Blocks';
            connectBtn.classList.remove('connection-mode');
            
            if (isRemoveConnectionMode) {
                btn.textContent = 'Exit Remove Mode';
                btn.classList.add('remove-connection-mode');
                document.getElementById('canvas').style.cursor = 'crosshair';
                document.getElementById('arrows').classList.add('remove-mode');
            } else {
                btn.textContent = 'Remove Connections';
                btn.classList.remove('remove-connection-mode');
                document.getElementById('canvas').style.cursor = 'grab';
                document.getElementById('arrows').classList.remove('remove-mode');
            }
            
            // Clear any selected blocks
            document.querySelector('.block.selected')?.classList.remove('selected');
            selectedBlock = null;
        }

        function openArrowTextModal(fromId, toId) {
            const connIndex = connections.findIndex(conn => conn.from === fromId && conn.to === toId);
            if (connIndex !== -1) {
                currentArrowIndex = connIndex;
                document.getElementById('arrowText').value = connections[connIndex].text || '';
                document.getElementById('arrowFontSize').value = connections[connIndex].fontSize || 12;
                document.getElementById('arrowTextModal').style.display = 'block';
            }
        }

        function saveArrowText() {
            if (currentArrowIndex !== -1) {
                const text = document.getElementById('arrowText').value.trim();
                const fontSize = parseInt(document.getElementById('arrowFontSize').value) || 12;
                connections[currentArrowIndex].text = text;
                connections[currentArrowIndex].fontSize = fontSize;
                renderConnections();
                saveToCache();
            }
            closeArrowTextModal();
        }

        function closeArrowTextModal() {
            document.getElementById('arrowTextModal').style.display = 'none';
            currentArrowIndex = -1;
        }

        function renderConnections() {
            const svg = document.getElementById('arrows');
            // Clear all existing content except the defs
            const defsContent = svg.querySelector('defs');
            svg.innerHTML = '';
            if (defsContent) {
                svg.appendChild(defsContent);
            } else {
                svg.innerHTML = `
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#ff6b6b" />
                        </marker>
                    </defs>
                `;
            }
            
            console.log('Rendering connections:', connections.length);
            
            // First pass: render all arrows
            connections.forEach((conn, index) => {
                const fromBlock = document.querySelector(`[data-block-id="${conn.from}"]`);
                const toBlock = document.querySelector(`[data-block-id="${conn.to}"]`);
                
                if (fromBlock && toBlock) {
                    const fromRect = fromBlock.getBoundingClientRect();
                    const toRect = toBlock.getBoundingClientRect();
                    const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                    
                    // Calculate block centers for comparison
                    const fromCenterX = fromRect.left + fromRect.width / 2;
                    const fromCenterY = fromRect.top + fromRect.height / 2;
                    const toCenterX = toRect.left + toRect.width / 2;
                    const toCenterY = toRect.top + toRect.height / 2;

                    // Determine relative positions
                    const isVerticalConnection = Math.abs(fromCenterY - toCenterY) > Math.abs(fromCenterX - toCenterX);
                    const fromIsAbove = fromCenterY < toCenterY;
                    const fromIsLeft = fromCenterX < toCenterX;

                    let fromX, fromY, toX, toY;

                    if (isVerticalConnection) {
                        if (fromIsAbove) {
                            fromX = fromCenterX;
                            fromY = fromRect.bottom;
                            toX = toCenterX;
                            toY = toRect.top;
                        } else {
                            fromX = fromCenterX;
                            fromY = fromRect.top;
                            toX = toCenterX;
                            toY = toRect.bottom;
                        }
                    } else {
                        if (fromIsLeft) {
                            fromX = fromRect.right;
                            fromY = fromCenterY;
                            toX = toRect.left;
                            toY = toCenterY;
                        } else {
                            fromX = fromRect.left;
                            fromY = fromCenterY;
                            toX = toRect.right;
                            toY = toCenterY;
                        }
                    }

                    // Convert to canvas coordinates
                    fromX = (fromX - canvasRect.left) / canvasZoom;
                    fromY = (fromY - canvasRect.top) / canvasZoom;
                    toX = (toX - canvasRect.left) / canvasZoom;
                    toY = (toY - canvasRect.top) / canvasZoom;
                    
                    // Create visible line with click handling
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', fromX);
                    line.setAttribute('y1', fromY);
                    line.setAttribute('x2', toX);
                    line.setAttribute('y2', toY);
                    line.setAttribute('class', 'arrow-line');
                    line.setAttribute('data-from', conn.from);
                    line.setAttribute('data-to', conn.to);
                    line.style.strokeWidth = '8';
                    line.style.pointerEvents = 'stroke';
                    
                    // Add click handler
                    line.onclick = function(e) {
                        if (isRemoveConnectionMode) {
                            const fromId = this.getAttribute('data-from');
                            const toId = this.getAttribute('data-to');
                            removeConnectionByIds(fromId, toId);
                        } else {
                            const fromId = this.getAttribute('data-from');
                            const toId = this.getAttribute('data-to');
                            openArrowTextModal(fromId, toId);
                        }
                        e.stopPropagation();
                        e.preventDefault();
                    };
                    
                    svg.appendChild(line);
                }
            });

            // Second pass: render all text labels on top
            connections.forEach((conn, index) => {
                if (conn.text && conn.text.trim() !== '') {
                    const fromBlock = document.querySelector(`[data-block-id="${conn.from}"]`);
                    const toBlock = document.querySelector(`[data-block-id="${conn.to}"]`);
                    
                    if (fromBlock && toBlock) {
                        const fromRect = fromBlock.getBoundingClientRect();
                        const toRect = toBlock.getBoundingClientRect();
                        const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                        
                        // Recalculate connection points (same logic as above)
                        const fromCenterX = fromRect.left + fromRect.width / 2;
                        const fromCenterY = fromRect.top + fromRect.height / 2;
                        const toCenterX = toRect.left + toRect.width / 2;
                        const toCenterY = toRect.top + toRect.height / 2;

                        const isVerticalConnection = Math.abs(fromCenterY - toCenterY) > Math.abs(fromCenterX - toCenterX);
                        const fromIsAbove = fromCenterY < toCenterY;
                        const fromIsLeft = fromCenterX < toCenterX;

                        let fromX, fromY, toX, toY;

                        if (isVerticalConnection) {
                            if (fromIsAbove) {
                                fromX = fromCenterX;
                                fromY = fromRect.bottom;
                                toX = toCenterX;
                                toY = toRect.top;
                            } else {
                                fromX = fromCenterX;
                                fromY = fromRect.top;
                                toX = toCenterX;
                                toY = toRect.bottom;
                            }
                        } else {
                            if (fromIsLeft) {
                                fromX = fromRect.right;
                                fromY = fromCenterY;
                                toX = toRect.left;
                                toY = toCenterY;
                            } else {
                                fromX = fromRect.left;
                                fromY = fromCenterY;
                                toX = toRect.right;
                                toY = toCenterY;
                            }
                        }

                        fromX = (fromX - canvasRect.left) / canvasZoom;
                        fromY = (fromY - canvasRect.top) / canvasZoom;
                        toX = (toX - canvasRect.left) / canvasZoom;
                        toY = (toY - canvasRect.top) / canvasZoom;
                        
                        const midX = (fromX + toX) / 2;
                        const midY = (fromY + toY) / 2;
                        const fontSize = conn.fontSize || 12;
                        
                        // Create background rectangle for text
                        const textBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        textElement.setAttribute('x', midX);
                        textElement.setAttribute('y', midY);
                        textElement.setAttribute('text-anchor', 'middle');
                        textElement.setAttribute('dominant-baseline', 'middle');
                        textElement.setAttribute('font-family', 'Segoe UI, sans-serif');
                        textElement.setAttribute('font-size', fontSize);
                        textElement.setAttribute('fill', '#333');
                        textElement.setAttribute('font-weight', 'bold');
                        textElement.textContent = conn.text;
                        
                        // Calculate text dimensions for background based on font size
                        const textWidth = conn.text.length * (fontSize * 0.6) + 8;
                        const textHeight = fontSize + 4;
                        
                        textBg.setAttribute('x', midX - textWidth/2);
                        textBg.setAttribute('y', midY - textHeight/2);
                        textBg.setAttribute('width', textWidth);
                        textBg.setAttribute('height', textHeight);
                        textBg.setAttribute('fill', 'rgba(255, 255, 255, 0.9)');
                        textBg.setAttribute('stroke', 'rgba(0, 0, 0, 0.2)');
                        textBg.setAttribute('stroke-width', '1');
                        textBg.setAttribute('rx', '4');
                        
                        svg.appendChild(textBg);
                        svg.appendChild(textElement);
                    }
                }
            });
            svg.setAttribute('width', canvas.style.width);
            svg.setAttribute('height', canvas.style.height);
        }

        function removeConnectionByIds(fromId, toId) {
            console.log('Removing connection from', fromId, 'to', toId);
            console.log('Connections before removal:', connections.length);
            
            if (confirm('Remove this connection?')) {
                const index = connections.findIndex(conn => conn.from === fromId && conn.to === toId);
                if (index !== -1) {
                    connections.splice(index, 1);
                    console.log('Connections after removal:', connections.length);
                    renderConnections();
                    saveToCache();
                } else {
                    console.log('Connection not found!');
                }
            }
        }

        function removeConnection(index) {
            console.log('Removing connection at index:', index, 'Total connections:', connections.length);
            console.log('Connection to remove:', connections[index]);
            
            if (confirm('Remove this connection?')) {
                connections.splice(index, 1);
                console.log('Connections after removal:', connections);
                renderConnections();
            }
        }

        function exportToJSON() {
            const exportData = {};
            
            for (const [blockId, block] of Object.entries(blocks)) {
                exportData[blockId] = {
                    id: blockId,
                    ...block.data
                };
            }
            
            document.getElementById('json-output').value = JSON.stringify(exportData, null, 4);
            document.getElementById('jsonModal').style.display = 'block';
        }

        function copyJSON() {
            const textarea = document.getElementById('json-output');
            textarea.select();
            document.execCommand('copy');
            alert('JSON copied to clipboard!');
        }

        function downloadJSON() {
            const exportData = {};
            
            for (const [blockId, block] of Object.entries(blocks)) {
                exportData[blockId] = {
                    id: blockId,
                    ...block.data
                };
            }
            
            const jsonString = JSON.stringify(exportData, null, 4);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `blocks_export_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function downloadSVG(return_svg_string = false) {
            if (Object.keys(blocks).length === 0) {
                alert('No blocks to export!');
                return;
            }
            
            // Helper function to format values for better wrapping
            function formatValue(value, maxLength = 40) {
                if (typeof value === 'string') {
                    return value;
                } else if (typeof value === 'object' && value !== null) {
                    if (Array.isArray(value)) {
                        // Format arrays with line breaks
                        if (value.length === 0) return '[]';
                        const items = value.map(item => 
                            typeof item === 'object' ? JSON.stringify(item) : String(item)
                        );
                        return '[' + items.join(', ') + ']';
                    } else {
                        // Format objects with line breaks
                        const entries = Object.entries(value);
                        if (entries.length === 0) return '{}';
                        const formatted = entries.map(([k, v]) => 
                            `${k}: ${typeof v === 'object' ? JSON.stringify(v) : String(v)}`
                        );
                        return '{' + formatted.join(', ') + '}';
                    }
                }
                return String(value);
            }
            
            // Helper function to wrap text properly
            function wrapText(text, maxWidth, fontSize = 12) {
                const charWidth = fontSize * 0.6; // Approximate character width
                const maxCharsPerLine = Math.floor(maxWidth / charWidth);
                
                if (text.length <= maxCharsPerLine) {
                    return [text];
                }
                
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                words.forEach(word => {
                    const testLine = currentLine ? currentLine + ' ' + word : word;
                    
                    if (testLine.length <= maxCharsPerLine) {
                        currentLine = testLine;
                    } else {
                        if (currentLine) {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            // Word is too long, need to break it
                            while (word.length > maxCharsPerLine) {
                                lines.push(word.substring(0, maxCharsPerLine - 1) + '-');
                                word = word.substring(maxCharsPerLine - 1);
                            }
                            currentLine = word;
                        }
                    }
                });
                
                if (currentLine) {
                    lines.push(currentLine);
                }
                
                return lines;
            }
            
            // Calculate bounding box of all blocks
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            Object.values(blocks).forEach(block => {
                const x = block.position.x;
                const y = block.position.y;
                const width = block.width || 320;
                const height = block.height || 480;
                
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x + width);
                maxY = Math.max(maxY, y + height);
            });
            
            // Add padding
            const padding = 50;
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;
            
            const width = maxX - minX;
            const height = maxY - minY;
            
            // Ensure minimum Full HD quality
            const scale = Math.max(1, Math.max(1920 / width, 1080 / height));
            const scaledWidth = width * scale;
            const scaledHeight = height * scale;
            
            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', scaledWidth);
            svg.setAttribute('height', scaledHeight);
            svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
            svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            
            // Add background
            const background = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            background.setAttribute('x', minX);
            background.setAttribute('y', minY);
            background.setAttribute('width', width);
            background.setAttribute('height', height);
            background.setAttribute('fill', 'url(#backgroundGradient)');
            
            // Add gradient definition
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradient.setAttribute('id', 'backgroundGradient');
            gradient.setAttribute('x1', '0%');
            gradient.setAttribute('y1', '0%');
            gradient.setAttribute('x2', '100%');
            gradient.setAttribute('y2', '100%');
            
            const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('stop-color', '#667eea');
            
            const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('stop-color', '#764ba2');
            
            gradient.appendChild(stop1);
            gradient.appendChild(stop2);
            defs.appendChild(gradient);
            
            // Add arrow marker
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '7');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '3.5');
            marker.setAttribute('orient', 'auto');
            
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
            polygon.setAttribute('fill', '#ff6b6b');
            
            marker.appendChild(polygon);
            defs.appendChild(marker);
            svg.appendChild(defs);
            svg.appendChild(background);
            
            // Add connections
            connections.forEach(conn => {
                const fromBlock = blocks[conn.from];
                const toBlock = blocks[conn.to];
                
                if (fromBlock && toBlock) {
                    // Get block dimensions with defaults
                    const fromWidth = fromBlock.width || 320;
                    const fromHeight = fromBlock.height || 480;
                    const toWidth = toBlock.width || 320;
                    const toHeight = toBlock.height || 480;
                    
                    // Calculate block centers for comparison
                    const fromCenterX = fromBlock.position.x + fromWidth / 2;
                    const fromCenterY = fromBlock.position.y + fromHeight / 2;
                    const toCenterX = toBlock.position.x + toWidth / 2;
                    const toCenterY = toBlock.position.y + toHeight / 2;
                    
                    // Determine relative positions
                    const isVerticalConnection = Math.abs(fromCenterY - toCenterY) > Math.abs(fromCenterX - toCenterX);
                    const fromIsAbove = fromCenterY < toCenterY;
                    const fromIsLeft = fromCenterX < toCenterX;
                    
                    let fromX, fromY, toX, toY;
                    
                    if (isVerticalConnection) {
                        // Vertical connection (blocks are stacked)
                        if (fromIsAbove) {
                            // From block is above to block
                            fromX = fromCenterX; // Center X of from block
                            fromY = fromBlock.position.y + fromHeight; // Bottom of from block
                            toX = toCenterX; // Center X of to block
                            toY = toBlock.position.y; // Top of to block
                        } else {
                            // From block is below to block
                            fromX = fromCenterX; // Center X of from block
                            fromY = fromBlock.position.y; // Top of from block
                            toX = toCenterX; // Center X of to block
                            toY = toBlock.position.y + toHeight; // Bottom of to block
                        }
                    } else {
                        // Horizontal connection (blocks are side by side)
                        if (fromIsLeft) {
                            // From block is left of to block
                            fromX = fromBlock.position.x + fromWidth; // Right side of from block
                            fromY = fromCenterY; // Center Y of from block
                            toX = toBlock.position.x; // Left side of to block
                            toY = toCenterY; // Center Y of to block
                        } else {
                            // From block is right of to block
                            fromX = fromBlock.position.x; // Left side of from block
                            fromY = fromCenterY; // Center Y of from block
                            toX = toBlock.position.x + toWidth; // Right side of to block
                            toY = toCenterY; // Center Y of to block
                        }
                    }
                    
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', fromX);
                    line.setAttribute('y1', fromY);
                    line.setAttribute('x2', toX);
                    line.setAttribute('y2', toY);
                    line.setAttribute('stroke', '#ff6b6b');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                    
                    svg.appendChild(line);
                }
            });

            // Add connection texts on top of arrows
            connections.forEach(conn => {
                const fromBlock = blocks[conn.from];
                const toBlock = blocks[conn.to];
                
                if (fromBlock && toBlock && conn.text && conn.text.trim() !== '') {
                    // Recalculate connection points (copy the same logic from above)
                    const fromWidth = fromBlock.width || 320;
                    const fromHeight = fromBlock.height || 480;
                    const toWidth = toBlock.width || 320;
                    const toHeight = toBlock.height || 480;
                    
                    const fromCenterX = fromBlock.position.x + fromWidth / 2;
                    const fromCenterY = fromBlock.position.y + fromHeight / 2;
                    const toCenterX = toBlock.position.x + toWidth / 2;
                    const toCenterY = toBlock.position.y + toHeight / 2;
                    
                    const isVerticalConnection = Math.abs(fromCenterY - toCenterY) > Math.abs(fromCenterX - toCenterX);
                    const fromIsAbove = fromCenterY < toCenterY;
                    const fromIsLeft = fromCenterX < toCenterX;
                    
                    let fromX, fromY, toX, toY;
                    
                    if (isVerticalConnection) {
                        if (fromIsAbove) {
                            fromX = fromCenterX;
                            fromY = fromBlock.position.y + fromHeight;
                            toX = toCenterX;
                            toY = toBlock.position.y;
                        } else {
                            fromX = fromCenterX;
                            fromY = fromBlock.position.y;
                            toX = toCenterX;
                            toY = toBlock.position.y + toHeight;
                        }
                    } else {
                        if (fromIsLeft) {
                            fromX = fromBlock.position.x + fromWidth;
                            fromY = fromCenterY;
                            toX = toBlock.position.x;
                            toY = toCenterY;
                        } else {
                            fromX = fromBlock.position.x;
                            fromY = fromCenterY;
                            toX = toBlock.position.x + toWidth;
                            toY = toCenterY;
                        }
                    }
                    
                    const midX = (fromX + toX) / 2;
                    const midY = (fromY + toY) / 2;
                    const fontSize = conn.fontSize || 12;
                                        
                    // Create background rectangle for text
                    const textBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    const textWidth = conn.text.length * (fontSize * 0.6) + 8;
                    const textHeight = fontSize + 4;
                    
                    textBg.setAttribute('x', midX - textWidth/2);
                    textBg.setAttribute('y', midY - textHeight/2);
                    textBg.setAttribute('width', textWidth);
                    textBg.setAttribute('height', textHeight);
                    textBg.setAttribute('fill', 'rgba(255, 255, 255, 0.9)');
                    textBg.setAttribute('stroke', 'rgba(0, 0, 0, 0.2)');
                    textBg.setAttribute('stroke-width', '1');
                    textBg.setAttribute('rx', '4');
                    
                    const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    textElement.setAttribute('x', midX);
                    textElement.setAttribute('y', midY);
                    textElement.setAttribute('text-anchor', 'middle');
                    textElement.setAttribute('dominant-baseline', 'middle');
                    textElement.setAttribute('font-family', 'Segoe UI, sans-serif');
                    textElement.setAttribute('font-size', fontSize);
                    textElement.setAttribute('fill', '#333');
                    textElement.setAttribute('font-weight', 'bold');
                    textElement.textContent = conn.text;

                    svg.appendChild(textBg);
                    svg.appendChild(textElement);
                }
            });
            
            // Add blocks
            Object.values(blocks).forEach(block => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                // Block background
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', block.position.x);
                rect.setAttribute('y', block.position.y);
                rect.setAttribute('width', block.width || 320);
                rect.setAttribute('height', block.height || 480);
                rect.setAttribute('fill', 'rgba(255, 255, 255, 0.95)');
                rect.setAttribute('stroke', 'rgba(255, 255, 255, 0.2)');
                rect.setAttribute('stroke-width', '1');
                rect.setAttribute('rx', '12');
                
                g.appendChild(rect);
                
                // Block title
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', block.position.x + 16);
                title.setAttribute('y', block.position.y + 30);
                title.setAttribute('font-family', 'Segoe UI, sans-serif');
                title.setAttribute('font-size', '16');
                title.setAttribute('font-weight', 'bold');
                title.setAttribute('fill', '#333');
                title.textContent = block.id;
                
                g.appendChild(title);
                
                // Block fields with proper wrapping
                let yOffset = 60;
                const maxWidth = (block.width || 320) - 32;
                const lineHeight = 18;
                const blockHeight = block.height || 480;
                const maxY = block.position.y + blockHeight - 20; // Leave some bottom padding

                Object.entries(block.data).forEach(([key, value]) => {
                    // Check if we have space for at least one line
                    if (block.position.y + yOffset + lineHeight > maxY) {
                        return; // Skip this field if no space
                    }
                    
                    // Format the value properly for wrapping
                    const formattedValue = formatValue(value);
                    const fullText = `${key}: ${formattedValue}`;
                    
                    // Use the improved wrapping function
                    const lines = wrapText(fullText, maxWidth, 12);
                    
                    // Render each line, but stop if we exceed block height
                    lines.forEach((line, lineIndex) => {
                        const lineY = block.position.y + yOffset + (lineIndex * lineHeight);
                        
                        // Check if this line would exceed the block height
                        if (lineY > maxY) {
                            return; // Skip this line and all subsequent lines
                        }
                        
                        const fieldText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        fieldText.setAttribute('x', block.position.x + 16);
                        fieldText.setAttribute('y', lineY);
                        fieldText.setAttribute('font-family', 'Segoe UI, sans-serif');
                        fieldText.setAttribute('font-size', '12');
                        fieldText.setAttribute('fill', '#2c3e50');
                        
                        if (lineIndex === 0) {
                            const keyMatch = line.match(/^([^:]+):(.*)/);
                            if (keyMatch) {
                                const keySpan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                                keySpan.setAttribute('font-weight', 'bold');
                                keySpan.textContent = keyMatch[1] + ':';
                                
                                const valueSpan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                                valueSpan.setAttribute('fill', '#34495e');
                                valueSpan.textContent = keyMatch[2];
                                
                                fieldText.appendChild(keySpan);
                                fieldText.appendChild(valueSpan);
                            } else {
                                fieldText.textContent = line;
                            }
                        } else {
                            fieldText.setAttribute('fill', '#34495e');
                            fieldText.textContent = line;
                        }
                        
                        g.appendChild(fieldText);
                    });
                    
                    yOffset += lines.length * lineHeight + 5;
                    
                    // Stop processing more fields if we're close to the bottom
                    if (block.position.y + yOffset > maxY) {
                        return;
                    }
                });
                
                svg.appendChild(g);
            });
            
            // Download SVG
            const svgString = new XMLSerializer().serializeToString(svg);
            if (!return_svg_string) {
                const blob = new Blob([svgString], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `blocks_diagram_${new Date().toISOString().slice(0, 10)}.svg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            return svgString
        }

        function downloadJPEG() {
            if (typeof blocks === 'undefined' || Object.keys(blocks).length === 0) {
                alert('No blocks to export!');
                return;
            }
            
            // Get SVG string from downloadSVG function
            const svgString = downloadSVG(true);
            if (!svgString) {
                alert('Error generating SVG for JPEG conversion');
                return;
            }
            
            // Calculate dimensions for high quality output
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
            const svgElement = svgDoc.documentElement;
            
            const width = parseFloat(svgElement.getAttribute('width'));
            const height = parseFloat(svgElement.getAttribute('height'));
            
            // Convert SVG to JPEG
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            canvas.width = width;
            canvas.height = height;
            
            img.onload = function() {
                // Fill with white background for JPEG
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                
                // Convert to JPEG blob
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `blocks_diagram_${new Date().toISOString().slice(0, 10)}.jpg`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 'image/jpeg', 0.95); // 95% quality
            };
            
            img.onerror = function() {
                alert('Error converting to JPEG. Please try again.');
            };
            
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const svgUrl = URL.createObjectURL(svgBlob);
            img.src = svgUrl;
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all blocks and connections?')) {
                blocks = {};
                connections = [];
                currentArrowIndex = -1;
                renderBlocks();
                updateCanvasSize();
                renderConnections();
                localStorage.removeItem('blockConstructorCache');
            }
        }

        function closeModal() {
            document.getElementById('blockModal').style.display = 'none';
        }

        function closeJSONModal() {
            document.getElementById('jsonModal').style.display = 'none';
        }

        function importFromJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    for (const [blockId, blockContent] of Object.entries(importedData)) {
                        const { id, ...fields } = blockContent;

                        blocks[blockId] = {
                            id: blockId,
                            data: fields,
                            position: {
                                x: Math.random() * 400 + 100,
                                y: Math.random() * 300 + 100
                            }
                        };
                    }
                    renderBlocks();
                    updateCanvasSize();
                    renderConnections();
                    saveToCache();
                    alert("Blocks imported successfully!");
                } catch (err) {
                    alert("Invalid JSON format");
                    console.error(err);
                }
            };
            reader.readAsText(file);
        }

        function openSaveGraphModal() {
            document.getElementById('saveGraphModal').style.display = 'block';
            document.getElementById('graphFileName').value = '';
            document.getElementById('saveGraphMessage').style.display = 'none';
        }

        function closeSaveGraphModal() {
            document.getElementById('saveGraphModal').style.display = 'none';
        }

        function checkGraphFileExists(fileName) {
            const url = "/check-graph-exists?file_name=" + encodeURIComponent(fileName);
            return fetch(url)
                .then(function (response) {
                    return response.json();
                })
                .then(function (data) {
                    return data.exists === true;
                })
                .catch(function (error) {
                    console.error("Error checking file existence:", error);
                    return false; // fallback if error
                });
        }

        function saveGraphToServer() {
            const fileNameInput = document.getElementById('graphFileName').value.trim();
            if (!fileNameInput) {
                showSaveGraphMessage('Please enter a file name');
                return;
            }

            const fileName = fileNameInput.endsWith('.graph.json') ? fileNameInput : fileNameInput + '.graph.json';
            checkGraphFileExists(fileName).then(function (exists) {
                if (exists) {
                    const confirmOverwrite = confirm(`File "${fileName}" already exists. Overwrite?`);
                    if (!confirmOverwrite) return;
                }

                // Step 2: Prepare the graph data for saving
                const cacheData = {
                    blocks: blocks,
                    connections: connections,
                    timestamp: Date.now()
                };

                // Step 3: Send the data to the server
                fetch('/save-graph', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        file_name: fileName,
                        graph_data: cacheData
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(err => { throw new Error(err.detail || 'Failed to save graph'); });
                    }
                    return response.json();
                })
                .then(data => {
                    showSaveGraphMessage(data.message, false);
                    // Optionally, close the modal after a short delay
                    setTimeout(() => {
                        closeSaveGraphModal();
                    }, 2000);
                })
                .catch(error => {
                    showSaveGraphMessage(error.message);
                });
            });
        }

        function showSaveGraphMessage(message, isError = true) {
            const msgElement = document.getElementById('saveGraphMessage');
            msgElement.textContent = message;
            msgElement.style.display = 'block';
            msgElement.style.color = isError ? '#ff6b6b' : '#2ecc71';
        }

        function openLoadGraphModal() {
            document.getElementById('loadGraphModal').style.display = 'block';
            loadGraphFilesList();
        }

        function closeLoadGraphModal() {
            document.getElementById('loadGraphModal').style.display = 'none';
        }

        function loadGraphFilesList() {
            fetch('/list-graphs')
            .then(response => response.json())
            .then(files => {
                const container = document.getElementById('graphFilesList');
                container.innerHTML = '';

                if (files.length === 0) {
                    container.innerHTML = '<p>No graph files found</p>';
                    return;
                }

                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'field-item';
                    fileItem.style.display = 'flex';
                    fileItem.style.justifyContent = 'space-between';
                    fileItem.style.alignItems = 'center';

                    const fileName = file.name;
                    const fileSize = (file.size / 1024).toFixed(2) + ' KB';
                    const fileModificationTime = file.mod_time_readable

                    fileItem.innerHTML = `
                        <div>
                            <span style="cursor: pointer; color: #3498db;" onclick="loadGraphFile('${fileName}')">${fileName}</span>
                            <span style="font-size: 0.8em; color: #7f8c8d;"> (${fileSize})</span>
                            <span style="font-size: 0.8em; color: #7f8c8d;"> (${fileModificationTime})</span>
                        </div>
                        <button class="remove-field" onclick="deleteGraphFile('${fileName}')">Delete</button>
                    `;

                    container.appendChild(fileItem);
                });
            })
            .catch(error => {
                console.error('Error loading graph files:', error);
                const container = document.getElementById('graphFilesList');
                container.innerHTML = '<p>Error loading graph files</p>';
            });
        }

        function loadGraphFile(fileName) {
            // We assume the file is served at /files/<filename>
            fetch(`/files/${fileName}`)
            .then(response => response.json())
            .then(data => {
                loadCacheData(data);
                closeLoadGraphModal();
            })
            .catch(error => {
                console.error('Error loading graph file:', error);
                alert('Failed to load graph file');
            });
        }

        function deleteGraphFile(fileName) {
            if (confirm(`Are you sure you want to delete ${fileName}?`)) {
                fetch(`/delete-graph/${fileName}`, {
                    method: 'DELETE'
                })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(err => { throw new Error(err.detail || 'Failed to delete'); });
                    }
                    return response.json();
                })
                .then(data => {
                    alert(data.message);
                    loadGraphFilesList(); // Refresh the list
                })
                .catch(error => {
                    alert(error.message);
                });
            }
        }

        // Close modals when clicking outside
        window.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.style.display = 'none';
                if (e.target.id === 'arrowTextModal') {
                    currentArrowIndex = -1;
                }
                if (e.target.id === 'editFieldModal') {
                    currentEditingFieldIndex = -1;
                }
                if (e.target.id === 'helpModal') {
                    closeHelpModal();
                }
            }
        });

        // Handle window resize for arrow repositioning
        window.addEventListener('resize', () => {
            setTimeout(renderConnections, 100);
        });

        window.onload = () => {
            loadFromCache();
            updateCanvasSize();
            canvasWrapper.scrollLeft = canvasWrapper.scrollWidth/2 - canvasWrapper.clientWidth/2;
            canvasWrapper.scrollTop = canvasWrapper.scrollHeight/2 - canvasWrapper.clientHeight/2;

            renderConnections();
        };

    </script>
</body>
</html>